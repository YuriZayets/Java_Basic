package OOP;

public class Answers {
    /**
     * 1.	Дайте развернутое объяснение трем концепциям ООП.

      - Абстракция – отбрасывание несущественных для данной задачи характеристик объекта, например для существования объекта,
     ему вовсе не обязательно иметь поведение, такое поведение может быть вынесено в интерфейс. Или машине совершенно не обязательно хранить данные о колёсах,
     важно лишь знать, что колёса в порядке, а уже сами экземпляры колёс хранят информацию о себе.
      - Инкапсуляция – подразумевает сокрытие внутренней реализации, Так при вождении автомобиля человеку не обязательно думать о его внутреннем устройстве,
     если он точно знает, что правая педаль – газ, а левая – тормоз он может в полной мере его использовать. Аналогично с модулями программы,
     если мы знаем что метод выполняет определённое действие, и знаем результат этого действия, нам ни к чему знать как он это делает.
     Это значительно упрощает делегирование разработки частей программы разным специалистам, а также создание технически сложных проектов.
      - Наследование – это расширение поведения, благодаря которому существует возможность создания шаблонов шаблонов объектов
     при котором наследники базового класса получают характеристики класса родителя и добавляют к ним свои собственные.
     При этом класс родитель (или шаблон шаблонов, как я его обозвал) является полноценным классом.
      - Полиморфизм – способность выбирать конкретный метод в зависимости от объекта, на котором он вызывается.
     Полиморфизм в купе с переопределением методов позволяет ещё расширить абстракцию.

     2.	Опишите процедуру инициализации полей класса и полей экземпляра класса. Когда инициализируются поля класса,
     а когда – поля экземпляров класса. Какие значения присваиваются полям по умолчанию? Где еще в классе полям могут быть присвоены начальные значения?
     Аналогичный вопрос был в разделе классы под номером 1

     3.	Приведите правила, которым должен следовать компонент java-bean.

     Должен иметь конструктор без параметров;
     Должен предоставлять доступ к параметрам через геттеры и сеттеры;
     Должен быть сериализуем для возможности сохранения и восстановления данных;
     Должен иметь переопределённые методы equals(), hashCode() и toString().

     4.	Дайте определение перегрузке методов. Как вы думаете, чем удобна перегрузка методов? Укажите, какие методы могут перегружаться, и какими методами они могут быть перегружены? Можно ли перегрузить методы в базовом и производном классах? Можно ли private метод базового класса перегрузить public методов производного? Можно ли перегрузить конструкторы, и можно ли при перегрузке конструкторов менять атрибуты доступа у конструкторов?
     Аналогичный вопрос был в разделе классы под номером 2
     5.	Объясните, что такое раннее и позднее связывание? Перегрузка – это раннее или позднее связывание? Объясните правила, которым следует компилятор при разрешении перегрузки; в том числе, если методы перегружаются примитивными типами, между которыми возможно неявное приведение или ссылочными типами, состоящими в иерархической связи.
     Аналогичный вопрос был в разделе классы под номером 3
     6.	Объясните, как вы понимаете, что такое неявная ссылка this? В каких методах эта ссылка присутствует, а в каких – нет, и почему?
     Аналогичный вопрос был в разделе классы под номером 4
     7.	Что такое финальные поля, какие поля можно объявить со спецификатором final? Где можно инициализировать финальные поля?
     Аналогичный вопрос был в разделе классы под номером 5
     8.	Что такое статические поля, статические финальные поля и статические методы. К чему имеют доступ статические методы? Можно ли перегрузить и переопределить статические методы? Наследуются ли статические методы?
     Аналогичный вопрос был в разделе классы под номером 6
     9.	Что такое логические и статические блоки инициализации? Сколько их может быть в классе, в каком порядке они могут быть размещены и в каком порядке вызываются?
     Аналогичный вопрос был в разделе классы под номером 7
     10.	Что представляют собой методы с переменным числом параметров, как передаются параметры в такие методы и что представляет собой такой параметр в методе? Как осуществляется выбор подходящего метода, при использовании перегрузки для методов с переменным числом параметров?
     Аналогичный вопрос был в разделе классы под номером 8
     11.	Чем является класс Object? Перечислите известные вам методы класса  Object, укажите их назначение.
     Аналогичный вопрос был в разделе классы под номером 9
     12.	Что такое хэш-значение? Объясните, почему два разных объекта могут сгенерировать одинаковые хэш-коды?
     Аналогичный вопрос был в разделе классы под номером 10
     13.	Как вы думаете, для чего используется наследование классов в java-программе? Приведите пример наследования.
     Как вы думаете, поля и методы, помеченными модификатором доступа private, наследуются?

     Наследование позволяет значительно уменьшить объём повторяющегося кода, упрощает понимание программы и обращение с объектами наследниками одного класса.
     Поля и методы, помеченные как private, не наследуются и остаются доступны только в самом классе.
     Ну почти всегда, кроме частного случая наследования методов использующих приватные поля без его переопределения:

     public class test {
     private final String message = "Моя переменная, никому не дам!";

     public static void main(String[] args) {
     Child child = new Child();
     child.message();
     }

     void message() {
     System.out.println(message);
     }
     }

     class Child extends test {
     }

     Это нельзя назвать полноценным наследованием, но судно Java в данном случае даёт течь, поскольку сообщение выводится даже без создания экземпляра Parent,
     хотя если верить теории, нестатическая переменная даже не должна инициализироваться. Ну или я что-то не так понимаю)

     14.	Укажите, как вызываются конструкторы при создании объекта производного класса? Что в конструкторе класса делает оператор super()?
     Возможно ли в одном конструкторе использовать операторы super() и this()?

     При вызове конструктора производного класса в первую очередь будет вызван конструктор базового класса,
     а уже после его завершения конструктор производного. Оператор super() и есть обращение к конструктору родительского класса,
     благодаря которому возможна передача части параметров для его отрабатывания, например

     public class Cleaner extends Worker {
     String name;
     int salary;
     Department department;

     public Cleaner (String name, int salary, Department department){
     super (name, salary); //передаём часть параметров в конструктор родительского класса
     this.department = department; //инициализируем параметры которых у родительского класса нет
     }
     }
     Использование super() и this() в одном конструкторе вполне возможно.

     15.	Объясните, как вы понимаете утверждения: “ссылка базового класса может ссылаться на объекты своих производных типов” и
     “объект производного класса может быть использован везде, где ожидается объект его базового типа”. Верно ли обратное и почему?

     Под этим утверждением я понимаю возможность уложить значение подкласса в более «широкую коробку» его родителя,
     то есть если класс Теннисный мяч наследуется от класса Мяч, то без проблем можно сделать следующее Мяч мяч = new Теннисный мяч();
     Поскольку при наследовании объект гарантированно обладает характеристиками своего родителя,
     а уже к ним может добавить ещё какие-то, то этот объект может без опаски быть использован везде где предполагался экземпляр его родителя.
     Однако в обратную сторону это не работает, поскольку нет никаких гарантий наличия у родителя всех полей расширяющего его класса.

     16.	Что такое переопределение методов? Как вы думаете, зачем они нужны? Можно ли менять возвращаемый тип при переопределении методов?
     Можно ли менять атрибуты доступа при переопределении методов? Можно ли переопределить методы в рамках одного класса?

     Переопределение методов это возможность сохранить имя метода у множества классов так или иначе связанных наследованием, чтобы при этом каждый класс имел свою реализацию.
     Согласно правилам переопределения метод должен:
     - принимать те же аргументы, что и родитель;
     - иметь тот же тип возвращаемого значения, что и родитель;
     - иметь тот же модификатор доступа, что и у родителя.

     Переопределить метод в рамках одного класса значит сделать ещё один такой же метод, что невозможно.

     17.	Определите правило вызова переопределенных методов. Можно ли статические методы переопределить нестатическими и наоборот?

     Переопределённые методы вызываются на объекте а не по типу ссылки, например:
     Car car1 = new Ferrari(); <- будет использовать переопределённые методы в класса Ferrari
     Car car2 = new Kamaz(); <- будет использовать переопределённые методы в класса Kamaz

     Переопределение статических методов невозможно, поскольку переопределение и его старший брат полиморфизм
     подразумевают выбор применяемого метода в рантайме для конкретного объекта, но статические методы относятся к раннему связыванию и принадлежат самому классу,
     поэтому такое поведение невозможно. В каком-то плане статический метод можно переопределить, но он просто заменит данный метод для всех ссылок на класс.
     Cтатические методы нельзя переопределять нестатическими и наоборот, поскольку они в принципе не подпадают под принцип переопределения и полиморфизма.

     18.	Какие свойства имеют финальные методы и финальные классы? Как вы думаете, зачем их использовать?

     Финальные методы обладают свойством «финализированности» реализации, то есть она конечна и не будет переопределяться в подклассах.
     Это свойство в некоторой степени повышает скорость компиляции (за счёт отсутствия необходимости убеждаться в отсутствии более подходящих перегрузок),
     но им скорее следует пользоваться в целях защиты и дизайна.
     Под дизайном в данном случае я понимаю возможность создания методов гарантированно присутствующих у данного класса и всех подклассов в неизменном виде.
     Например если мы создали класс Кот с финальным методом toТыгыдык(), мы точно хотим быть уверенны, что все представители кошачьих будут это уметь и делать это одинаково.
     Финальные классы, «генеалогически» выражаясь, являются тупиковым путём, то есть не могут иметь наследников.
     Это опять же увеличивает скорость компиляции и повышает их защищенность в плане отсутствия нескольких реализаций из-за наследования.

     19.	Укажите правила приведения типов при наследовании. Напишите примеры явного и неявного преобразования ссылочных типов.
     Объясните, какие ошибки могут возникать при явном преобразовании ссылочных типов.

     Приведении типов при наследовании в основном встречается в контексте upcast когда значение наследника присваивается ссылочной переменной его родителя,
     такое приведение выполняется неявно, поскольку наследник гарантированно обладает всеми характеристиками родителя.
     При обратном преобразовании (dowcast) всегда существует риск выпадения ошибки ClassCastException, который берёт на себя программист,
     IDE всегда укажет на место, где такой каст происходит и попросит дополнить код явным указателем преобразования.
     Чтобы избежать ошибки можно использовать оператор instanceOf чтобы убедиться что данный объект является представителем определённого класса.

     20.	Что такое объект класса Class? Чем использование метода getClass() и последующего сравнения возвращенного значения с
     Type.class отличается от использования оператора instanceof?
     Аналогичный вопрос был в разделе классы под номером 11
     21.	Укажите правила переопределения методов equals(), hashCode() и toString().
     Аналогичный вопрос был в разделе классы под номером 12
     22.	Что такое абстрактные классы и методы? Зачем они нужны? Бывают ли случаи, когда абстрактные методы содержат тело?
     Можно ли в абстрактных классах определять конструкторы? Могут ли абстрактные классы содержать неабстрактные методы?
     Можно ли от абстрактных классов создавать объекты и почему?

     Абстрактный класс и содержащиеся в нём методы это своего рода заготовка под будущие классы.
     Причина их существования аналогична причине существования наследования в целом, за тем различием, что создавать экземпляры абстрактного класса нельзя.
     Абстрактные методы не могут иметь тело и являются исключительно напоминанием о необходимости реализации при наследовании.
     В абстрактных классах можно без проблем определять конструкторы, но вызвать их напрямую для создания экземпляра нельзя,
     они будут использоваться только по ссылке super() классов наследников.
     В абстрактном классе может быть сколько угодно неабстрактных методов, может даже не быть ни одного абстрактного.
     Создать экземпляр абстрактного класса нельзя потому, что он является лишь основой будущих классов.

     23.	Что такое интерфейсы? Как определить и реализовать интерфейс в java-программе? Укажите спецификаторы, которые приобретают методы и поля,
     определенные в интерфейсе. Можно ли описывать в интерфейсе конструкторы и создавать объекты? Можно ли создавать интерфейсные ссылки и если да,
     то на какие объекты они могут ссылаться?

     Интерфесы – специальный функционал, расширяющий возможности применения ООП, являясь пакетом методов и констант, которые можно добавить к классу.
     Интерфейс определяется аналогично классу, только вместо ключевого слова class пишется interface,
     для имплементирования интерфейса в классе используется ключевое слово implements.
     Методы в интерфейсе имеют модификатор abstract (кроме случаев модификатора default после java8), а все переменные public static final.
     В интерфейсе не может быть конструкторов и создавать его экземпляры нельзя.
     Интерфейсные ссылки аналогичны ссылками на классы, их можно использовать в коллекциях, принимать в качестве параметров в методы и т.д.,
     однако всё это касается только объектов реализующих данный интерфейс.

     24.	Для чего служит интерфейс Clonable? Как правильно переопределить метод clone() класса Object, для того, что объект мог создавать свои адекватные копии?

     Интерфейс Clonable служит меткой того, что программист считает возможным создавать копии объектов помеченного им класса.
     При переопределении метода clone() после имплементации метода Clonable нужно уделить вниманием копированию ссылочных переменных,
     т.к. базовая реализация метода просто скопирует ссылки на них, не создавая копии самих объектов, что сделает копии объектов зависимыми друг от друга.

     25.	Для чего служат интерфейсы Comparable и Comparator? В каких случаях предпочтительнее использовать первый, а когда – второй? Как их реализовать и использовать?

     Данные интерфейсы применяются для сравнения чего-то посложнее чем примитивные типы данных. Например если существует два экземпляра класса с 3 полями,
     вопрос по каким признакам их сравнивать будет возникать постоянно, особенно при автосортировке в коллекциях.
     Comparable – имплементируется классом с переопределением метода compareTo(), если он возвращает отрицательно значение, значит объект,
     переданный в качестве параметра, больше того, на котором был вызван, если положительное, то наоборот.
     Comparator применяется когда нужный нам класс не имплементирует интерфейс Comparable или его реализация в данном случае не подходит.
     Для использования Comparator зачастую создаётся отдельный класс его имплементирующий, в этом классе определяются требуемые методы,
     а затем экземпляр этого класса передаётся в качестве аргумента при создании или сортировке коллекции.
     Comparator > Comparable и будет заменять собой его реализацию.

     Generic classes and Interfaces, Enums
     1.	Что такое перечисления в Java. Как объявить перечисление? Чем являются элементы перечислений? Кто и когда создает экземпляры перечислений?

     Перечисления в java это специальный класс созданный для хранения статических констант.
     Объявляется он с помощью ключевого слово enum вместо class
     enum NamesForRussiansInHollywoodMovies {IVAN, YURI}
     элементы перечисления являются эксземплярами класса со всеми вытекающими последствиями в том числе наличие у них своих полей, объявленных в enum.
     Экземпляры перечислений создаются в момент создания класса enum.

     2.	Можно ли самостоятельно создать экземпляр перечисления? А ссылку типа перечисления?
     Как сравнить, что в двух переменных содержится один и тот же элемент перечисления и почему именно так?

     Самостоятельно создавать экземпляры перечисления нельзя, все конструкторы в enum имеют модификатор private.
     Думаю что ссылку типа перечисления создать нельзя, т.к. при этом подразумевается обращение к конструктору, а доступ к нему ограничен.
     Для сравнения двух переменных нет разницы что использовать == или equals() потому как все enumы неявно наследуются от Java.lang.Enum в котором определён метод equals()
     с модификатором final и внутри себя он использует ==.
     Если вдруг возникла необходимость сравнить два Enum по значениям их полей, то можно использовать Comparable и Comparator

     3.	Что такое анонимные классы?

     Анонимный класс – локальный класс для одноразового использования.
     Для java он выглядит как класс без имени, может иметь ссылочный тип интерфейса, при этом будет создан анонимный класс,
     имплементирующий этот интерфейс, который будет обязан реализовать все его методы.
     Такие классы также имеют ограничения внутренних классов – запрет на создание статических переменных и методов,
     а также зону видимости только в пределах метода где они применяются.

     4.	Что такое параметризованные классы? Для чего они необходимы? Приведите пример параметризованного класса и пример создания объекта параметризованного класса?
     Объясните, ссылки какого типа могут ссылаться на объекты параметризованных классов? Можно ли создать объект, параметризовав его примитивным типом данных?

     Параметризированные классы – классы применяющие в качестве параметров обобщённые типы.
     Параметризированные классы я бы назвал частным случаем перегрузки, они упрощают читаемость кода и применение определённых в классе методов.
     Пример:
     public int Searcher<T>{
     public int SeatchInArray (Type[] T, Type item){
     for (int i = 0; i < T.lenght; i++){
     if (item = T[i]) return i;
     }
     }
     }
     При создании экземпляров обобщённых классов невозможно использование примитивных типов данных, только их оболочек – объектов.


     Exceptions and Errors
     1.	Что для программы является исключительной ситуацией? Какие способы обработки ошибок в программах вы знаете?

     Пожалуй исключительная ситуация это ситуация когда продолжение хода программы или её корректное завершение не представляется возможным.
     Существует 2 официальных способа обработки ошибок и третий способ – мой фаворит:
     - обработка ошибки в try-catch;
     - передача ошибки вверх по стеку вызовов;
     - тот, которым в данный момент обычно пользуюсь я //картинка с девочкой креститься

     2.	Что такое исключение для Java-программы? Что значит “программа выбросила исключение”?
     Опишите ситуации, когда исключения выбрасываются виртуальной машиной(автоматически), и когда необходимо их выбрасывать вручную?

     Исключение это в целом  незапланированная ситуация или критическая ошибка возникающая в ходе действия программы.
     Программа выбросила исключение – значит,
     что в ходе работы программы произошли определённые условия при которых программа самостоятельно не в состоянии продолжить работу,
     например мы просим предоставить элемент массива под индексом, который не входит в его диапазон.
     Исключение выбрасывается автоматически, когда виртуальная машина встречает определённый триггер, такой как деление на 0,
     в случае если при написании программы не предусмотрены действия на случай его срабатывания, программа экстренно завершит работу.
     Выбрасывать исключения вручную можно для дополнительной проверки состояния объекта или результата вычислений.
     Например, если каждый раз при взаимодействии с машиной мы хотим убеждаться что в ней достаточно топлива, а иначе выбрасывать CarHasNoFuelException,
     то мы можем создать одноимённый класс, наследовать его от Exception и в дальнейшем использовать эту проверку в разных частях программы.

     3.	Приведите иерархию классов-исключений, делящую исключения на проверяемые и непроверяемые. В чем особенности проверяемых и непроверяемых исключений?

     Исключения делятся на проверяемые и непроверяемые по принципу отслеживания их компилятором, часть исключений,
     таких например как FileNotFoundException заранее известны и весьма вероятны и обязательно должны быть обработаны.
     Однако чтобы не навязывать проверки ошибок при каждом делении двух чисел, часть ошибок сделали не проверяемым и необходимость их проверки отдали на откуп программисту.

     4.	Объясните работу оператора try-catch-finally. Когда данный оператор следует использовать? Сколько блоков catch может соответствовать одному блоку try?
     Можно ли вкладывать блоки try друг в друга, можно ли вложить блок try в catch или finally?
     Как происходит обработка исключений, выброшенных внутренним блоком try, если среди его блоков catch нет подходящего?
     Что называют стеком операторов try? Как работает блок try с ресурсами.

     Оператор try-catch-finally это комплекс блоков кода, выполнение которых происходит при определённых условиях,
     try срабатывает первым и в случае выбрасывания исключения, обрабатываемого блоком catch передаёт ему управление,
     после передачи управления из блоков try-catch выполняется блок кода finally, обычно это закрытие потоков и освобождение ресурсов,
     которое должно происходить независимо от результатов работы try-catch.
     Количество используемых блоков catch не ограничено ничем кроме логики.
     Блоки try можно вкладывать в catch и finally, если среди внутренних блоков catch не найдётся подходящего для обработки исключения,
     исключение будет передано во внешний слой и по возможности обработано там.
     Стек операторов try – несколько операторов try вызывающих друг друга (вложенных друг в друга)?
     try  с ресурсами – более современная версия try-catch-finally, которая автоматически освободит задействованные ресурсы после завершения работы над блоком кода

     5.	Укажите правило расположения блоков catch в зависимости от типов перехватываемых исключений.
     Может ли перехваченной исключение быть сгенерировано снова, и, если да, то как и кто в этом случае будет обрабатывать повторно сгенерированное исключение?
     Может ли блок catch выбрасывать иные исключения, и если да, то опишите ситуацию, когда это может быть необходимо.

     Блоки catch должны располагаться от более частных, к более общим, иначе более широкое исключение,
     такое как Exception перехватит большую часть исключений и другие блоки, расположенные за ним будут недосягаемы.
     Думаю, что исключения сгенерированные в блоке catch обрабатывать будет либо наружный try-catch, если такой имеется, либо их можно передать выше по стеку вызовов.
     Предположу что ситуация с выбрасыванием нового исключения в catch может возникнуть при необходимости обобщения ошибки.
     Например, мы из приложения обратились к стороннему софту внутри которого произошла ошибка, мне может быть не очень интересно какая конкретно ошибка произошла внутри,
     мне лишь важно знать, что софт не отработал и вернулось что-то вроде SoftNeSmogException и я буду понимать что он не смог и обрабатывать уже эту ошибку.

     6.	Когда происходит вызов блока finally? Существуют ли ситуации, когда блок finally не будет вызван?
     Может ли блок finally выбрасывать исключений? Может ли блок finally выполнится дважды?

     Вызов блока finally происходит после блока try (хотя на самом деле много частных случаев)
     Блок final может не быть вызван только в особых случаях (сбой питания, бесконечный цикл в try, принудительное завершение работы и т.д.) или вызове System.exit();
     В finally можно выбрасывать исключения, оно перекроет собой предыдущее исключение пришедшее в этот блок.
     Думаю, что блок finally не может выполняться дважды, поскольку в него редко включается код для которого повторное выполнение разумно.
     *
     */
}
